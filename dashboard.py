# -*- coding: utf-8 -*-
"""dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11B56SxfDPHc89vDyNFtqqnM6UD_Pp94m
"""

!pip install streamlit pandas plotly shap matplotlib pyngrok prophet

# Commented out IPython magic to ensure Python compatibility.
# %%writefile dashboard.py
# 
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# import shap
# import matplotlib.pyplot as plt
# import pickle
# import joblib
# import os
# from google.colab import drive
# from prophet import Prophet
# import plotly.graph_objects as go
# 
# 
# model_path = "/content/drive/MyDrive/kpi_degradation_rf_model.pkl"
# if os.path.exists(model_path):
#     model = joblib.load(model_path)
#     print("Model Loaded Successfully!")
# else:
#     raise FileNotFoundError("Model not found in Google Drive!")
# 
# df = pd.read_csv("final_feature_engineered_data.csv")
# 
# features = ['cpu_usage', 'memory_usage', 'response_time', 'error_rate']
# X = df[features]
# y = df["transaction_success_rate"]
# 
# explainer = shap.TreeExplainer(model)
# shap_values = explainer.shap_values(X)
# 
# # --- FEATURE IMPORTANCE ---
# st.subheader("üîç Feature Importance (SHAP Analysis)")
# shap_df = pd.DataFrame(
#     {"Feature": X.columns, "SHAP Importance": np.abs(shap_values).mean(axis=0)}
# ).sort_values(by="SHAP Importance", ascending=False)
# 
# fig = px.bar(shap_df, x="SHAP Importance", y="Feature", orientation="h", title="Top Features Driving KPI")
# st.plotly_chart(fig)
# 
# 
# daily_df = pd.read_csv("daily_aggregated_features.csv")
# 
# # # --- KPI TREND VISUALIZATION ---
# st.subheader("üìà KPI Trend Over Time")
# fig = px.line(daily_df, x=daily_df['date'], y="transaction_success_rate", title="KPI Performance")
# st.plotly_chart(fig)
# 
# 
# # --- Forecasting ---
# prophet_df = daily_df.reset_index().rename(columns={"date": "ds", "transaction_success_rate": "y"})
# 
# # # Train a Prophet model
# model = Prophet()
# model.fit(prophet_df)
# 
# # Make future predictions
# future = model.make_future_dataframe(periods=30)
# forecast = model.predict(future)
# 
# # Plot results
# st.subheader("Forecasting")
# fig = go.Figure()
# fig.add_trace(go.Scatter(x=prophet_df["ds"], y=prophet_df["y"], mode='markers', name="Actual Data"))
# fig.add_trace(go.Scatter(x=forecast["ds"], y=forecast["yhat"], mode='lines', name="Forecast"))
# 
# # Display in Streamlit
# st.plotly_chart(fig)
# 
# 
# # --- SYSTEM HEALTH MONITORING ---
# st.subheader("üñ•Ô∏è System Health Monitoring")
# cols = st.columns(4)
# for i, metric in enumerate(["response_time", "error_rate", "cpu_usage", "memory_usage"]):
#     value = df[metric].iloc[-1]
#     cols[i].metric(label=metric.replace("_", " ").title(), value=value, delta=f"{value - df[metric].mean():.2f}")
# 
# 
# # --- ALERTS & RECOMMENDATIONS ---
# st.subheader("‚ö†Ô∏è Alerts & Recommendations")
# if df["transaction_success_rate"].iloc[-1] < 0.6:
#     st.error("üö® KPI is below the threshold! Investigate high response times & errors.")
# elif df["transaction_success_rate"].iloc[-1] < 0.8:
#     st.warning("‚ö†Ô∏è KPI is slightly below the optimal range. Monitor system performance.")
# else:
#     st.success("‚úÖ KPI is within the acceptable range.")

!ngrok authtoken 2tR24bBRgEpqgMj1oblanxWAJ5T_LZLrzxRUscfVKTZ94KwH

from pyngrok import ngrok

# Kill any existing tunnels
ngrok.kill()

# Start Streamlit
!streamlit run dashboard.py &>/dev/null &

import time
time.sleep(5)

# Create a public URL using ngrok
public_url = ngrok.connect(8501)

print(f"Streamlit is running! Open: {public_url}")